# Caesar Cipher

## Problem Statement
Encrypt, decrypt, and analyze substitution ciphers where each alphabetic character is shifted by a fixed offset. The tool supports classical Caesar cipher experimentation, brute-force cracking, and basic frequency analysis.

## Usage
- Encrypt or decrypt from the CLI:
  ```bash
  python caesar.py encrypt "Hello World" 3
  python caesar.py decrypt "Khoor Zruog" 3
  ```
- Attempt to crack an unknown shift via frequency analysis:
  ```bash
  python caesar.py crack "Wklv lv d vhfuhw"
  ```
- Launch the interactive helper:
  ```bash
  python caesar.py --interactive
  ```

### Haskell command-line companion
- Compile the standalone binary with `ghc` (ships with the Haskell Platform or `ghcup`):
  ```bash
  ghc --make Caesar.hs -o caesar-hs
  ```
- Run it with familiar flags to mirror the Python output format:
  ```bash
  ./caesar-hs --mode encrypt --shift 3 --text "Hello World"
  ./caesar-hs --mode decrypt --shift 3 --text "Khoor Zruog" --verbose
  ./caesar-hs --brute-force --text "Wklv lv d vhfuhw" --top 10
  ```
  `--alphabet` accepts `letters`, `alphanumeric`, or `printable`, matching the presets documented below.
- Pipe Haskell results into the visualizer workflow by capturing the output and feeding it to the Python tooling. For example,
  ```bash
  BEST=$(./caesar-hs --brute-force --text "Wklv lv d vhfuhw" | tail -n 1 | sed -E "s/.*'(.+)' .*/\1/")
  python cipher_visualizer.py --cipher caesar --shift 3 --text "$BEST" --output-json caesar.json
  ```
  Any plaintext generated by the Haskell binary can be dropped into `cipher_visualizer.py`'s `--text` argument so frequency
  plots stay in sync with the CLI experiments.

### Visual exploration
- Generate substitution maps, frequency charts, and optional Plotly outputs with the shared visualizer:
  ```bash
  python cipher_visualizer.py --cipher caesar --shift 5 --text "Meet me at the park" --output-json caesar.json --output-html caesar.html
  ```
- Add `--show` for an interactive window, or `--no-plot --pretty` to print just the JSON data when running headless (e.g., in CI).

## Debugging Tips
- Known plaintext pairs are great smoke tests. For example, encrypting `abc` with shift `1` should produce `bcd`.
- Run the script with `--verbose` (logging set to `INFO`) to see alphabet normalization and scoring decisions.
- No automated tests ship with this module, but you can add `pytest`-style cases by asserting round trips: `decrypt(encrypt(text, k), k) == text`.

## Implementation Notes
- Supports multiple alphabet presets (letters, alphanumeric, printable) and normalizes case internally.
- Includes brute-force enumeration and Chi-squared scoring to rank candidate plaintexts.
- Designed for both command-line usage and import as a library module.

## Further Reading
- [Wikipedia: Caesar cipher](https://en.wikipedia.org/wiki/Caesar_cipher)
- [Katz & Lindell, *Introduction to Modern Cryptography* â€“ Chapter on Classical Ciphers](https://doi.org/10.1201/9781315311140)
