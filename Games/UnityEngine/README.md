# Unity Challenge Engine

A reusable Unity foundation for tackling future `/g/` programming challenges. The project lives under `Games/UnityEngine` and
ships an entity/component runtime, lightweight event bus, deterministic scene management helpers, JSON serialisation, and editor
extensions that streamline authoring.

## Project Layout

```
Games/UnityEngine/
├── Assets/
│   ├── Content/                  # Data imported via custom pipelines
│   ├── Editor/                   # Inspector tooling + scripted importers
│   ├── Scenes/                   # Sample scenes demonstrating architecture
│   └── Scripts/
│       ├── ECS/                  # Entity/component primitives and systems
│       ├── Events/               # Event bus implementation
│       ├── Scenes/               # Scene catalog and loader runtime
│       ├── Serialization/        # World save/load helpers
│       └── Samples/              # Authoring behaviours + demo systems
├── Packages/                     # Unity package manifest (generated by Unity)
└── ProjectSettings/              # Unity generated project settings
```

The Unity folders (Packages/ProjectSettings) are placeholders so Unity can bootstrap the project without prompting for an
upgrade path. When you open the project they will be rewritten with your editor defaults.

## Unity Version

The code targets **Unity 2022.3 LTS** (tested against `2022.3.21f1`). Opening with a newer LTS release is safe; Unity will
re-import assets and regenerate `.meta` files that are missing editor-specific data.

## Features

### Entity / Component Model

* `ChallengeEngine.ECS.World` tracks entities, component membership, and registered systems.
* `ComponentBehaviour` bridges Unity `MonoBehaviour` scripts to the world so authoring stays familiar.
* `WorldBridge` owns a singleton `World` instance per scene and exposes an update tick.
* `EntityAuthoring` automatically registers attached components into the world at runtime.

### Event Bus

* `ChallengeEngine.Events.EventBus` offers strongly typed publish/subscribe channels.
* Scene transitions emit `SceneLoadStarted`, `SceneLoadProgress`, and `SceneLoadCompleted` events via the bus for debugging and
  UI feedback.

### Scene Management

* `SceneCatalog` aggregates logical scene tags and resolves them to `.unity` assets.
* `SceneLoader` handles asynchronous scene loads, optional loading overlays, and exposes events through the bus.
* `SampleScenes.sceneasset.json` demonstrates a scripted importer that keeps catalog data versionable.

### Serialization

* `WorldSerializer` converts entity/component graphs into JSON snapshots using opt-in `ISerializableComponent` implementations.
* `SpinComponent` shows how components can ship a nested `SerializableComponentData` to round-trip runtime data.

### Editor Tooling

* `SceneCatalogInspector` provides a curated inspector for catalog assets, including quick buttons to ping target scenes.
* `SceneDefinitionImporter` turns JSON descriptors into usable Unity assets and keeps custom data pipelines scriptable.

## Sample Scenes

* **Menu** (`Assets/Scenes/Menu.unity`) – boots the ECS `World`, registers the scene loader, and points to the JSON-driven scene
  catalog.
* **Spinner Demo** (`Assets/Scenes/SpinnerDemo.unity`) – demonstrates component authoring, ECS registration, and the rotating
  system powered by the `SpinSystem` MonoBehaviour.

Use the menu scene as your entry point. Press play and trigger `SceneLoader.LoadByTag("spinner")` from the inspector to observe
loading events while the spinner scene animates.

## Extending the Engine

1. **Create new components** by inheriting from `ComponentBehaviour` and, optionally, `ISerializableComponent` when the data
   should persist. Register systems that consume them via `World.RegisterSystem`.
2. **Listen to events** by subscribing to the shared `EventBus` on `SceneLoader`. Dispose the subscription to avoid leaks during
   domain reloads.
3. **Add scenes** by editing the JSON descriptor or using the `SceneCatalog` asset directly. Link buttons/UI to the loader using
   logical tags instead of raw scene paths.
4. **Integrate content pipelines** by creating additional `ScriptedImporter` classes in `Assets/Editor`. The sample importer can
   be cloned and adjusted for audio banks, dialog graphs, or combat stats.
5. **Automate saves** via `WorldSerializer`. Compose a `SerializableEntity` by collecting the components that opt-in to saves and
   call `Save`/`Load` during transitions.

## Build Instructions

1. Install [Unity Hub](https://unity.com/download) and add the **Unity 2022.3.21f1** editor.
2. From Unity Hub choose **Open → Add project from disk…** and select `Games/UnityEngine`.
3. Let Unity import assets. The editor will regenerate missing `Packages/` and `ProjectSettings/` entries.
4. Open `Assets/Scenes/Menu.unity` and press **Play** to validate the setup.
5. Build player targets through **File → Build Settings…**. Add both sample scenes to the build list before building Windows,
   macOS, or WebGL players.

## Testing Checklist

* The spinner rotates in Play Mode when the scene loader sends the `spinner` tag.
* Scene catalog inspector shows quick actions for editing entries.
* Importing `*.sceneasset.json` files auto-generates `SceneCatalog` assets.

Feel free to extend this foundation with rendering pipelines, physics systems, or scripting interfaces as new challenges demand.
